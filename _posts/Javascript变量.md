title: Javascript变量
date: 2013-08-18 22:41:58
tags: ['Javascript','基础']
description: ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。引用类型值则是指那些保存在堆内存中的对象，即变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。
---
### 基本类型和引用类型

ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。
*基本类型值*指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。
*引用类型值*则是指那些保存在堆内存中的对象，即变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。
我们通常认为数字、字符串等按值传递；数组、对象等按地址（引用）传递。对此种观点，我们要谨慎。比如以下的代码：

```
var a = [1,2,3] ;
var b = a ;
a = [1,2] ;
console.log(b); // [1,2,3]
```

```
var a = [1,2,3] ;
var b = a ;
a.pop();
console.log(b); // [1,2]
```

<!--more-->

我们会发现两者结果存在差异。第一段代码中b貌似是按值传递的，而第二段代码b貌似是引用传递。
实际的情况是`a=[1,2]`;这段赋值语句实现时地址指向改变了，指向了新的数组。而b依然指向的原来的数组。而`a.pop()`只是对`a`进行操作，不会改变地址的指向。 同理以下代码：

```
var obj1 = new Object();
var obj2 = obj1;
obj1.name = 'Apple';
console.log(obj2.name); // 'Apple'
obj1 = {name: 'Google'};
console.log(obj2.name); // 'Apple'
//此时重写了obj1对象，obj1指向了新的对象。
```

### 函数传递参数

*ECMAScript中所有的函数都是按值传递的。*也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一变量一样。基本类型的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。
在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

```
var v1 = []
var v2 = {};
var v3 = {};
function foo(v1, v2, v3)
{
    v1 = [1];
    v2 = [2];
    v3 = {a:3}
}

foo(v1, v2, v3);
alert (v1); // 空白 
alert (v2); // [object Object] 
alert (v3.a); // undefined
```

```
var v1 = []
var v2 = {};
var v3 = {a:0};
function foo(v1, v2, v3)
{
    v1.push (1);
    v2.a = 2;
    v3.a = 3;
}

foo(v1, v2, v3);
alert (v1); // 1 
alert (v2.a); // 2 
alert (v3.a); // 3
```